module chocopy

imports
  
  Common

context-free start-symbols
  
  Program

context-free sorts

  Exp
  Def
  Stmt
  SimpleStmt
  Target
  Declaration
  TypedVar
  TypedVarList
  Type
  Expr
  ExprConstant
  MemberExpr
  IndexExpr
  Operator
  Literal
  Program
  Block
  IfBlock
  ElseIfBlock
  ElseBlock
  VarDef
  FunctionDeclarations
  FunctionDef
  FunctionBody
  AllDefinitions
  

context-free syntax

	
	//This is ambigous when a block has multiple statements
	// I need to be able to include all statements in the block
	Program.Program = <<AllDefinitions*> <Stmt*>>
	
	AllDefinitions.FunctionDefinition = <<FunctionDef>>
	AllDefinitions.VarDefinition = <<VarDef>>
	AllDefinitions.ClassDefinition = <<ClassDef>>


	//TODO fix function def to support multiargs
	FunctionDef.FnDef = "def" ID "(" TypedVarList ")" "->" Type ":" fnBody:FunctionBody {layout(newline-indent "def" fnBody)}
	FunctionBody.FnBody = fnDecl:FunctionDeclarations* fnStmt:Block {layout(align fnDecl fnStmt)}
	
	ClassDef.ClsDef = "class" ID"(" ID ")" ":" clsBody:ClassBody {layout(newline-indent "class" clsBody)}
	
	ClassBody.ClsEmpty = "pass"
	ClassBody.ClsVars = <<VarDef+>>
	ClassBody.ClsFn = <<FunctionDef+>>
	
	
	
	

	//block = NEWLINE INDENT stmt+ DEDENT
	Block.Block = sts:Stmt+ {layout(align-list sts)}

	
	IfBlock.IfBlock = "if" Expr":" blk:Block {layout(newline-indent "if" blk)}
	ElseBlock.ElseBlock = "else:" blk:Block {layout(newline-indent "else:" blk)}
	ElifBlock.ElifBlock = "elif" Expr ":" blk:Block {layout(newline-indent "elif" blk)}
	
	Stmt.StmtIf = ifBlk:IfBlock elifBlk:ElifBlock* elseBlk:ElseBlock? {layout(align ifBlk elifBlk && align elifBlk elseBlk )}
	Stmt.While = "while" Expr":" blk:Block {layout(newline-indent "while" blk)}
	Stmt.For = "for" ID "in" Expr":" blk:Block {layout(newline-indent "for" blk)}
	Stmt.SimpleStmt = <<SimpleStmt>>
	

	SimpleStmt.Pass = "pass"
	SimpleStmt.Expression = <<Expr>>
	SimpleStmt.RetSimpleStmt = <return <Expr>>
	SimpleStmt.TargetSimpleStmt = <<Target> = <Expr>> 
	//TODO SimpleStmt.TargetSimpleStmt = <<{Target "="}+> <Expr>>

	Target.Identifier = <<ID>>
	Target.TargetMember = <<MemberExpr>>
	Target.TargetIndex = <<IndexExpr>>
	
	Type.TypeID = <<ID>>
	Type.TypeString = <<STRING>>
	Type.CollectionType = <[<Type>]>
	
	TypedVar.TypedVar = <<ID> : <Type>>
	TypedVarList.TypedVarList = <<{TypedVar ","}*>>

	Declaration.Global 		= <global <ID>>
	Declaration.NonLocal 	= <nonlocal <ID>>

	
	FunctionDeclarations.FnLocalGlobals = <<Declaration>>
	FunctionDeclarations.FnVarDef = <<VarDef>> 
	FunctionDeclarations.FnFnDef = <<FunctionDef>>
	
	
	

	

	
	VarDef.VarDef 	= <<TypedVar> = <Literal>>
	Expr 			= <(<Expr>)>							{bracket}
	Expr.NotExpr	= <not <Expr>>
	Expr.And		= <<Expr> and <Expr>>					{left}
	Expr.Or			= <<Expr> or <Expr>>					{left}
	Expr.IfElse		= <<Expr> if <Expr> else <Expr>>		{right}
	Expr.Constant	= <<ExprConstant>>

	
	ExprConstant.VarId		= <<ID>>
	ExprConstant.ExprLit 	= <<Literal>>
	ExprConstant.ListLit 	=  <[<{Expr ", "}*>]>
	ExprConstant.ParenLit 	= <(<Expr>)>						
	ExprConstant.Index		= IndexExpr
	ExprConstant.MemberCall	= <<MemberExpr>(<{Expr ","}*>)>
	ExprConstant.FuncCall	= <<ID>(<{Expr ","}*>)>
	ExprConstant.Plus	= <<ExprConstant> + <ExprConstant>>		{left}
	ExprConstant.Minus	= <<ExprConstant> - <ExprConstant>>		{left}
	ExprConstant.Times	= <<ExprConstant> * <ExprConstant>>		{left}
	ExprConstant.Div	= <<ExprConstant> // <ExprConstant>>	{left}
	ExprConstant.Mod	= <<ExprConstant> % <ExprConstant>>		{left}
	ExprConstant.Eq		= <<ExprConstant> == <ExprConstant>>	{non-assoc}	
	ExprConstant.NotEq	= <<ExprConstant> != <ExprConstant>>	{non-assoc}	
	ExprConstant.GtEq	= [[ExprConstant] >= [ExprConstant]]	{non-assoc}	
	ExprConstant.Gt		= [[ExprConstant] > [ExprConstant]]		{non-assoc}	
	ExprConstant.LtEq	= [[ExprConstant] <= [ExprConstant]]	{non-assoc}	
	ExprConstant.Lt		= [[ExprConstant] < [ExprConstant]]		{non-assoc}	
	ExprConstant.Is		= [[ExprConstant] is [ExprConstant]]	{non-assoc}	



	MemberExpr.MemberExpr 	= <<ExprConstant>.<ID>>
	
	IndexExpr.IdIndex		= <<ID>[<ExprConstant>]>
	IndexExpr.StringIndex		= <<STRING>[<ExprConstant>]>
	
	Literal.None 		= "None"
	Literal.LitTrue 	= "True"
	Literal.LitFalse	= "False"
	Literal.Integer 	= <<INT>>
	Literal.String 		= <<STRING>>
	//Possible Fix this Literal.IdString	=<<IdString>>
	
	
	
context-free priorities

  {ExprConstant.Div} > {ExprConstant.Times} > ExprConstant.Plus > ExprConstant.Minus
  //,
  //Program.JustDef > Program.Mixed
  //Block.Block > Stmt.SimpleStmt
  
	
	
	

